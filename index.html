<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Analizador Profesional de Rentabilidad por Equipo</title>
<script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>

<style>
body { font-family: Arial; background: #f4f4f9; padding: 20px; }
.container { max-width: 1150px; margin: auto; background: white; padding: 25px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,.1); }
h1 { text-align: center; color: #4caf50; border-bottom: 2px solid #4caf50; padding-bottom: 10px; }
.controls { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:15px; }
.input-group { display: flex; flex-direction: column; width: 150px; }
.input-group label { font-size: 0.8em; color: #555; margin-bottom: 4px; }
select, input:not([type="file"]), button { padding:10px; border:1px solid #ccc; border-radius:4px; }
table { width:100%; border-collapse:collapse; margin-top:15px; }
th, td { border:1px solid #ddd; padding:10px; }
th { background:#4caf50; color:white; }
.rentable { color:#2e7d32; font-weight:bold; }
.no-rentable { color:#d32f2f; font-weight:bold; }
.neutral { color:#555; font-weight:bold; }
button { cursor:pointer; background:#4caf50; color:white; border:none; transition:.3s; }
button:hover { background:#388e3c; }
.error-message { color: red; font-weight: bold; margin-top: 15px; padding: 10px; border: 1px solid red; border-radius: 4px; }
</style>
</head>

<body>
<div class="container">
<h1>‚öΩ Analizador Profesional de Equipos</h1>

<div class="controls">
<input type="file" id="fileInput" accept=".xlsx">

<select id="filtroPosicion">
    <option value="all">Local + Visitante</option>
    <option value="home">Solo Local</option>
    <option value="away">Solo Visitante</option>
</select>

<select id="filtroLiga">
    <option value="all">Todas las Ligas</option>
</select>

<select id="filtroLimite">
    <option value="0">Hist√≥rico completo</option>
    <option value="15">√öltimos 15 partidos por equipo</option>
</select>

<div class="input-group">
    <label for="victoryInput">Valor de Victoria (Excel):</label>
    <input type="text" id="victoryInput" placeholder="Ej: Acierto, Correcto" value="" onchange="recalcular()">
</div>

<button onclick="exportarExcel()">Exportar a Excel</button>
</div>

<div id="resultados"></div>
</div>

<script>
let datosGlobales = [];
let rankingFinal = [];
let columnasMapeadas = {}; 

document.getElementById('fileInput').addEventListener('change', cargarArchivo);
document.querySelectorAll('select').forEach(e => e.addEventListener('change', recalcular));

// --- FUNCIONES DE UTILIDAD PARA ROBUSTEZ DE DATOS ---

const normalizeHeader = (header) => String(header).toLowerCase().replace(/[^a-z0-9]/g, '');

function obtenerNombresColumnas(data) {
    if (data.length === 0) return false;
    
    const requiredCols = { 
        'Match': ['match'], 
        'Odd': ['odd', 'cuota'], 
        'Result': ['result', 'resultado', 'outcome', 'resul'],
        'League': ['league', 'liga'], 
        'Date': ['date', 'fecha'] 
    };
    
    const realHeaders = Object.keys(data[0]);
    const mappedCols = {};
    let foundAll = true;
    
    for (const key in requiredCols) {
        let found = false;

        for (const realHeader of realHeaders) {
            const normalizedReal = normalizeHeader(realHeader);
            
            if (requiredCols[key].some(keyword => normalizedReal.includes(keyword))) {
                mappedCols[key] = realHeader;
                found = true;
                break;
            }
        }
        
        if (!found) {
            document.getElementById('resultados').innerHTML = `<p class="error-message">Error: No se encontr√≥ la columna clave "${key}". Se intent√≥ buscar [${requiredCols[key].join(', ')}].</p>`;
            foundAll = false;
        }
    }
    
    columnasMapeadas = mappedCols;
    return foundAll;
}

function parseFechaSeguro(fecha) {
    if (!fecha) return new Date(0);
    if (typeof fecha === "number") return XLSX.SSF.parse_date_code(fecha); 
    const partes = String(fecha).split("/");
    if (partes.length === 3) {
        return new Date(`${partes[2]}-${partes[1]}-${partes[0]}`); 
    }
    return new Date(fecha); 
}

/**
 * Determina si el resultado es victoria, incluyendo valores fijos y el valor personalizado del input.
 */
function esWinSeguro(valor) {
    if (!valor) return false; 
    const v = String(valor).toUpperCase().trim();
    
    // Lista de valores fijos para victoria, incluyendo 'WINNING'
    let winValues = ["WIN","WINNING","1","W","TRUE","SI"];

    // Agregar valor personalizado del input
    const customWinValue = document.getElementById('victoryInput').value;
    if (customWinValue) {
        winValues.push(String(customWinValue).toUpperCase().trim());
    }

    return winValues.includes(v);
}

/**
 * Determina si el resultado es derrota (p√©rdida de la unidad).
 * Se asume que si el resultado no es WIN, es LOSS/VOID/DRAW, pero esta funci√≥n busca valores expl√≠citos.
 */
function esLossSeguro(valor) {
    if (!valor) return false;
    const v = String(valor).toUpperCase().trim();
    // Lista de valores expl√≠citos para derrota, incluyendo 'LOSING'
    let lossValues = ["LOSS", "LOSING", "0", "L", "FALSE", "NO", "FALLO", "FAIL"];
    // Si la columna de resultado est√° vac√≠a, o contiene algo que no es victoria,
    // pero queremos una detecci√≥n m√°s estricta de la derrota.
    return lossValues.includes(v);
}


// --- L√ìGICA PRINCIPAL ---

function cargarArchivo(e) {
    const reader = new FileReader();
    document.getElementById('resultados').innerHTML = '';
    
    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        datosGlobales = XLSX.utils.sheet_to_json(sheet, { defval: "" });

        if (!obtenerNombresColumnas(datosGlobales)) return; 
        
        datosGlobales.sort((a,b)=> parseFechaSeguro(a[columnasMapeadas.Date]) - parseFechaSeguro(b[columnasMapeadas.Date]));
        
        cargarLigas();
        recalcular();
    };
    reader.readAsArrayBuffer(e.target.files[0]);
}

function cargarLigas() {
    const ligas = [...new Set(datosGlobales.map(r => r[columnasMapeadas.League]).filter(l => l && String(l).trim() !== ''))];
    const select = document.getElementById("filtroLiga");
    select.innerHTML = '<option value="all">Todas las Ligas</option>';
    ligas.forEach(l => {
        const opt = document.createElement("option");
        opt.value = l;
        opt.textContent = l;
        select.appendChild(opt);
    });
}

function recalcular() {
    if (Object.keys(columnasMapeadas).length < 5 || datosGlobales.length === 0) {
        if (document.getElementById('fileInput').files.length > 0) {
            // Este mensaje se muestra si se carg√≥ el archivo pero fall√≥ el mapeo
             document.getElementById("resultados").innerHTML = `<p class="error-message">Falta el mapeo de columnas. Por favor, aseg√∫rate que los encabezados coinciden o intenta recargar el archivo.</p>`;
        }
        return; 
    }

    const posicion = document.getElementById("filtroPosicion").value;
    const liga = document.getElementById("filtroLiga").value;
    const limite = Number(document.getElementById("filtroLimite").value);

    let datos = [...datosGlobales];
    
    if (liga !== "all") datos = datos.filter(d => String(d[columnasMapeadas.League]) === liga);

    procesarDatos(datos, posicion, limite);
}

function procesarDatos(data, posicion, limite) {
    const porEquipo = {};

    data.forEach(row => {
        const matchValue = String(row[columnasMapeadas.Match] || "");

        // Extracci√≥n de Equipos
        let teams = [];
        if (matchValue.includes("-") || matchValue.includes("‚Äì")) {
             teams = matchValue.split(/\s*[-‚Äì]\s*/).map(t => t.trim());
        } else if (matchValue.toLowerCase().includes("vs")) {
            teams = matchValue.split(/\s+vs\s+/i).map(t => t.trim());
        }

        if (teams.length !== 2 || !teams[0] || !teams[1]) return;
        const [home, away] = teams;
        
        const odd = Math.max(parseFloat(row[columnasMapeadas.Odd]) || 1, 1);
        const resultValue = row[columnasMapeadas.Result];
        
        const isWin = esWinSeguro(resultValue);
        // const isLoss = esLossSeguro(resultValue); // Esta l√≠nea es para referencia, pero no la usaremos directamente para el c√°lculo de Profit/Loss.

        if (!porEquipo[home]) porEquipo[home] = [];
        if (!porEquipo[away]) porEquipo[away] = [];

        porEquipo[home].push({ tipo: "home", isWin, odd });
        porEquipo[away].push({ tipo: "away", isWin, odd });
    });

    const resultados = {};

    Object.entries(porEquipo).forEach(([team, partidos]) => {

        let partidosUsados = limite > 0 ? partidos.slice(-limite) : partidos;
        let usados = partidosUsados.filter(p => posicion === "all" || p.tipo === posicion);

        if (!usados.length) return;

        let profit = 0, aciertos = 0;

        usados.forEach(p => {
            // üí° L√ìGICA CLAVE: Si es Victoria, suma la ganancia. Si NO es Victoria, resta 1 (asume p√©rdida/nulo).
            profit += p.isWin ? (p.odd - 1) : -1;
            if (p.isWin) aciertos++;
        });

        resultados[team] = {
            Partidos: usados.length,
            Aciertos: aciertos,
            Profit: profit,
            ROI: (profit / usados.length) * 100
        };
    });

    rankingFinal = Object.entries(resultados).map(([Equipo, d]) => ({
        Equipo,
        Partidos: d.Partidos,
        Aciertos: d.Aciertos,
        WinRate: ((d.Aciertos / d.Partidos) * 100).toFixed(1),
        Profit: d.Profit.toFixed(2),
        ROI: d.ROI.toFixed(2)
    })).sort((a,b)=> parseFloat(b.Profit) - parseFloat(a.Profit));

    mostrarTabla();
}

// --- VISUALIZACI√ìN Y EXPORTACI√ìN ---

function mostrarTabla() {
    if (rankingFinal.length === 0) {
        const msg = datosGlobales.length > 0 && Object.keys(columnasMapeadas).length === 5 
            ? "No se encontraron equipos o no hay datos v√°lidos para los filtros seleccionados." 
            : "Cargue un archivo v√°lido para comenzar el an√°lisis.";
            
        document.getElementById("resultados").innerHTML = `<p class="error-message">${msg}</p>`;
        return;
    }
    
    let html = `<table>
    <tr>
        <th>Equipo</th><th>Partidos</th><th>Aciertos</th><th>Win%</th>
        <th>Profit</th><th>ROI%</th><th>Estado</th>
    </tr>`;

    rankingFinal.forEach(e => {
        const p = parseFloat(e.Profit);
        const estado = p > 0 ? "Rentable" : p < 0 ? "P√©rdida" : "Neutro";
        const clase = p > 0 ? "rentable" : p < 0 ? "no-rentable" : "neutral";

        html += `
        <tr>
            <td>${e.Equipo}</td>
            <td>${e.Partidos}</td>
            <td>${e.Aciertos}</td>
            <td>${e.WinRate}%</td>
            <td class="${clase}">${e.Profit} u</td>
            <td class="${clase}">${e.ROI}%</td>
            <td class="${clase}">${estado}</td>
        </tr>`;
    });

    html += "</table>";
    document.getElementById("resultados").innerHTML = html;
}

function exportarExcel() {
    if (!rankingFinal.length) {
        alert("No hay datos para exportar.");
        return;
    }
    const ws = XLSX.utils.json_to_sheet(rankingFinal);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Ranking Equipos");
    XLSX.writeFile(wb, "ranking_rentabilidad_equipos.xlsx");
}
</script>
</body>
</html>
