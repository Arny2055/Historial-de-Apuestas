<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtester Semanal DEBUG: BTTS S√≠ & Over 2.5</title>
    <style>
        body { font-family: 'Roboto', sans-serif; margin: 20px; background: #f9f9f9; color: #333; line-height: 1.6; }
        #container { max-width: 1200px; margin: auto; padding: 20px; background: white; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-radius: 8px; }
        h1, h2 { color: #123456; }
        button { padding: 10px 20px; background: #3d8bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #2a6bcc; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input[type="checkbox"] { margin-right: 10px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 8px; border: 1px solid #ddd; text-align: center; }
        th { background: #123456; color: white; }
        tr:nth-child(even) { background: #f5f5f5; }
        .positive { color: #2a9d8f; font-weight: bold; }
        .negative { color: #e63946; font-weight: bold; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; }
        .stat-box { padding: 15px; background: #f0f8ff; border-radius: 6px; text-align: center; }
        .stat-box p { font-size: 1.4em; font-weight: bold; margin: 5px 0 0; }
        .stat-box span { font-size: 0.9em; color: #56789a; }
        #status { margin: 10px 0; padding: 10px; border-radius: 4px; background: #e8f5e8; color: #2a9d8f; }
        #error { background: #ffebee; color: #c62828; }
        .details { display: none; margin-top: 10px; }
        .details.show { display: block; }
        .market-btts { background: #e3f2fd; }
        .market-over { background: #f3e5f5; }
    </style>
</head>
<body>
<div id="container">
    <h1>Backtester Semanal DEBUG: Prioridad BTTS (Odd real)</h1>
    <p>Carga JSON. Logs en Console (F12). Filtros relajados para generar bets. Si 0 resultados, copia logs aqu√≠.</p>
    
    <input type="file" id="json-input" accept=".json" onchange="loadJSON()">
    <label><input type="checkbox" id="include-over" checked> Incluir Over 2.5 (simulado)</label>
    <button id="run-btn" onclick="runSimulation()" disabled>üî¨ Simular (DEBUG)</button>
    <div id="status">Estatus: Esperando JSON...</div>
    
    <section id="results-section" style="display: none;">
        <h2>üìä Resultados Agregados</h2>
        <div class="stats-grid">
            <div class="stat-box"><span>Semanas Simuladas</span><p id="total-weeks">0</p></div>
            <div class="stat-box"><span>Unidades Netas</span><p id="net-units" class="positive">0.00</p></div>
            <div class="stat-box"><span>Yield Promedio (%)</span><p id="avg-yield" class="positive">0.00%</p></div>
            <div class="stat-box"><span>Tasa de Acierto (%)</span><p id="win-rate">0.00%</p></div>
        </div>
        
        <h2>Detalles por Semana</h2>
        <table id="weekly-table">
            <thead>
                <tr>
                    <th>Semana (Domingo)</th>
                    <th>Mercados</th>
                    <th>Unidades</th>
                    <th>Yield (%)</th>
                    <th>EV Promedio (%)</th>
                    <th>Acciones</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        
        <div id="details-section"></div>
    </section>
</div>

<script>
    let allData = [];
    const SIX_MONTHS_MS = 6 * 30 * 24 * 60 * 60 * 1000;
    const ONE_WEEK_MS = 7 * 24 * 60 * 60 * 1000;
    const MIN_MATCHES = 5; // Relajado
    const EDGE_MARGIN = 0.05; // Relajado
    const PROB_MIN = 0.50; // Relajado para debug
    const PROB_MAX = 0.85; // Relajado
    const CORRELATION_FACTOR = 0.04;
    const DECAY_FACTOR = 0.95;
    const MATCHES_LIMIT = 3; // Relajado

    // Poisson (mismo)
    const factorialCache = { 0: 1, 1: 1 };
    function factorial(n) {
        if (n in factorialCache) return factorialCache[n];
        let result = 1;
        for (let i = 2; i <= n; i++) result *= i;
        return factorialCache[n] = result;
    }

    function poisson(k, lambda) {
        if (k < 0) return 0;
        if (lambda <= 0) return k === 0 ? 1 : 0;
        return (Math.exp(-lambda) * Math.pow(lambda, k)) / factorial(k);
    }

    function runPoissonSimulation(lambdaL, lambdaV, correlationFactor) {
        const maxGoals = 4;
        let probMatrix = [];
        let totalProb = 0;
        const P_plus = (lambda) => 1 - Array.from({ length: maxGoals }, (_, k) => poisson(k, lambda)).reduce((a, b) => a + b, 0);

        for (let i = 0; i <= maxGoals; i++) {
            probMatrix[i] = [];
            for (let j = 0; j <= maxGoals; j++) {
                const probL = (i < maxGoals) ? poisson(i, lambdaL) : P_plus(lambdaL);
                const probV = (j < maxGoals) ? poisson(j, lambdaV) : P_plus(lambdaV);
                probMatrix[i][j] = probL * probV;
                totalProb += probMatrix[i][j];
            }
        }

        const normFactor = 1.0 / totalProb;
        let normalizedProbMatrix = probMatrix.map(row => row.map(p => p * normFactor));
        let finalProbMatrix = JSON.parse(JSON.stringify(normalizedProbMatrix));

        if (correlationFactor > 0) {
            const prob00 = normalizedProbMatrix[0][0];
            const prob11 = normalizedProbMatrix[1][1];
            const sumDraws = prob00 + prob11;
            if (sumDraws > 0) {
                finalProbMatrix[0][0] += correlationFactor * (prob00 / sumDraws);
                finalProbMatrix[1][1] += correlationFactor * (prob11 / sumDraws);
                const sumDrawsNew = finalProbMatrix[0][0] + finalProbMatrix[1][1];
                const sumNonDrawsOrig = 1.0 - sumDraws;
                const sumNonDrawsReq = 1.0 - sumDrawsNew;
                const reduction = sumNonDrawsOrig > 0 ? sumNonDrawsReq / sumNonDrawsOrig : 1.0;
                for (let i = 0; i <= maxGoals; i++) {
                    for (let j = 0; j <= maxGoals; j++) {
                        if (!((i === 0 && j === 0) || (i === 1 && j === 1))) {
                            finalProbMatrix[i][j] = normalizedProbMatrix[i][j] * reduction;
                        }
                    }
                }
            }
        }

        let probBTTS = 0, probOU25 = 0;
        for (let i = 0; i <= maxGoals; i++) {
            for (let j = 0; j <= maxGoals; j++) {
                const P = finalProbMatrix[i][j];
                if (i >= 1 && j >= 1) probBTTS += P;
                if (i + j > 2) probOU25 += P;
            }
        }

        return { probBTTS, probOU25 };
    }

    function loadJSON() {
        const file = document.getElementById('json-input').files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                let rawData = JSON.parse(e.target.result);
                if (!Array.isArray(rawData)) rawData = [rawData];

                allData = rawData.map((match, idx) => {
                    const [localTeam, visitantTeam] = match.Match.split(' - ');
                    const [homeGoalsStr, awayGoalsStr] = match['Result FT'] ? match['Result FT'].split('-') : ['0', '0'];
                    const homeGoals = parseInt(homeGoalsStr) || 0;
                    const awayGoals = parseInt(awayGoalsStr) || 0;
                    const dateStr = match.Date.replace(/^(lun\.|mar\.|mi√©\.|jue\.|vie\.|s√°b\.|dom\.\,?\s?)?/i, '');
                    const date = new Date(dateStr);

                    let outcome = 'UNKNOWN';
                    const desired = (match['Desired Outcome'] || '').toUpperCase();
                    if (desired === 'GG') outcome = 'BTTS';
                    else if (desired === 'OVER 2.5') outcome = 'OVER';

                    console.log(`Parse partido ${idx}: ${match.Match}, Date: ${dateStr} ‚Üí ${date.toLocaleString()}, Outcome: ${outcome}, Odd: ${match.Odd}, Goles: ${homeGoals}-${awayGoals}`);

                    return {
                        date: isNaN(date.getTime()) ? new Date(0) : date,
                        league: match.League,
                        localTeam: localTeam ? localTeam.trim() : 'Unknown L',
                        visitantTeam: visitantTeam ? visitantTeam.trim() : 'Unknown V',
                        homeGoals,
                        awayGoals,
                        odd: parseFloat(match.Odd) || 2.0,
                        outcome,
                        result: match.Result === 'Winning' ? 'Ganada' : 'Perdida',
                        homeShots: parseInt(match['Home OnGoal Shots at FT']) || 3,
                        awayShots: parseInt(match['Away OnGoal Shots at FT']) || 3
                    };
                }).filter(m => m.date.getTime() > 0) // Fechas v√°lidas
                  .sort((a, b) => a.date - b.date);

                if (allData.length === 0) throw new Error('No fechas v√°lidas. Formato: "lun., 31 mar. 2025 18:00".');
                
                console.log(`Total partidos parseados: ${allData.length}. Rango fechas: ${allData[0].date.toLocaleDateString()} a ${allData[allData.length-1].date.toLocaleDateString()}`);
                
                document.getElementById('status').innerHTML = `<span class="positive">‚úÖ ${allData.length} partidos cargados. BTTS: ${allData.filter(m => m.outcome === 'BTTS').length}. Ver Console para parse.</span>`;
                document.getElementById('run-btn').disabled = false;
            } catch (err) {
                console.error('Error parse JSON:', err);
                document.getElementById('status').id = 'error';
                document.getElementById('status').innerHTML = `<span class="negative">‚ùå ${err.message}. Ver Console.</span>`;
            }
        };
        reader.readAsText(file);
    }

    function runSimulation() {
        if (allData.length === 0) return;
        document.getElementById('results-section').style.display = 'block';
        document.getElementById('status').innerHTML = '<span class="positive">DEBUG: Simulando. Ver Console para cada paso.</span>';
        let skippedFixtures = 0, skippedReasons = {};

        const includeOver = document.getElementById('include-over').checked;
        const startDate = allData[0].date;
        const endDate = allData[allData.length - 1].date;
        let currentSunday = new Date(startDate.getTime() + SIX_MONTHS_MS);
        currentSunday.setDate(currentSunday.getDate() + ((7 - currentSunday.getDay()) % 7));

        const weeklyResults = [];
        let totalUnits = 0, totalBets = 0, totalWins = 0, totalEVSum = 0;

        let weekCount = 0;
        while (currentSunday < endDate && weekCount < 20) { // L√≠mite 20 semanas para debug
            weekCount++;
            const windowStart = new Date(currentSunday.getTime() - SIX_MONTHS_MS);
            const nextWeekStart = new Date(currentSunday.getTime() + 24 * 60 * 60 * 1000);
            const nextWeekEnd = new Date(currentSunday.getTime() + ONE_WEEK_MS);

            const statsData = allData.filter(m => m.date >= windowStart && m.date < currentSunday);
            const fixtures = allData.filter(m => m.date >= nextWeekStart && m.date < nextWeekEnd);

            console.log(`\n=== SEMANA ${weekCount} (${currentSunday.toLocaleDateString()}) ===`);
            console.log(`  Ventana stats: ${statsData.length} partidos (desde ${windowStart.toLocaleDateString()})`);
            console.log(`  Fixtures semana: ${fixtures.length} partidos`);

            if (statsData.length < MIN_MATCHES || fixtures.length === 0) {
                const reason = statsData.length < MIN_MATCHES ? 'pocos stats' : 'sin fixtures';
                skippedReasons[reason] = (skippedReasons[reason] || 0) + 1;
                skippedFixtures += fixtures.length;
                console.log(`  SKIP: ${reason} (stats:${statsData.length}, fixtures:${fixtures.length})`);
                currentSunday = new Date(currentSunday.getTime() + ONE_WEEK_MS);
                continue;
            }

            const weekResults = simulateWeekBacktest(statsData, fixtures, includeOver);
            weeklyResults.push({
                weekStart: currentSunday.toLocaleDateString('es-ES'),
                bets: weekResults.bets,
                units: weekResults.units,
                yield: weekResults.yield,
                evAvg: weekResults.evAvg,
                details: weekResults.details
            });

            totalUnits += weekResults.units;
            totalBets += weekResults.bets;
            totalWins += weekResults.wins;
            totalEVSum += weekResults.evAvg * weekResults.bets;

            console.log(`  RESULTADO: ${weekResults.bets} bets, units ${weekResults.units.toFixed(2)}, yield ${weekResults.yield.toFixed(2)}%`);

            currentSunday = new Date(currentSunday.getTime() + ONE_WEEK_MS);
        }

        console.log(`\n=== RESUMEN DEBUG ===`);
        console.log(`Semanas totales: ${weeklyResults.length}, Bets totales: ${totalBets}`);
        console.log('Skipped reasons:', skippedReasons);

        updateUI(weeklyResults, totalUnits, totalBets, totalWins, totalEVSum / (totalBets || 1));
        document.getElementById('status').innerHTML = `<span class="positive">‚úÖ Completa. Bets: ${totalBets}. Skipped: ${skippedFixtures} fixtures (${Object.entries(skippedReasons).map(([k,v]) => `${k}:${v}`).join(', ')}). Ver Console.</span>`;
    }

    function simulateWeekBacktest(stats, fixtures, includeOver) {
        let bets = 0, units = 0, wins = 0, totalEV = 0;
        const details = [];

        const globalAvgHomeShots = stats.reduce((sum, m) => sum + m.homeShots, 0) / stats.length || 3;
        const globalAvgAwayShots = stats.reduce((sum, m) => sum + m.awayShots, 0) / stats.length || 3;
        console.log(`  Globals: Avg home shots ${globalAvgHomeShots.toFixed(1)}, away ${globalAvgAwayShots.toFixed(1)}`);

        fixtures.forEach((fixture, fixIndex) => {
            console.log(`  Fixture ${fixIndex + 1}: ${fixture.localTeam} vs ${fixture.visitantTeam} (${fixture.outcome}), Odd ${fixture.odd}, Goles real ${fixture.homeGoals}-${fixture.awayGoals}`);

            let teamLHomeStats = stats.filter(m => m.localTeam === fixture.localTeam && m.league === fixture.league).slice(-MATCHES_LIMIT);
            let teamVAwayStats = stats.filter(m => m.visitantTeam === fixture.visitantTeam && m.league === fixture.league).slice(-MATCHES_LIMIT);

            // Fallback si pocos stats
            if (teamLHomeStats.length < MATCHES_LIMIT) {
                console.log(`    Fallback stats local: usando global avg`);
                teamLHomeStats = Array(MATCHES_LIMIT).fill(globalAvgHomeShots);
            }
            if (teamVAwayStats.length < MATCHES_LIMIT) {
                console.log(`    Fallback stats visit: usando global avg`);
                teamVAwayStats = Array(MATCHES_LIMIT).fill(globalAvgAwayShots);
            }

            const GF_L = weightedAvg(teamLHomeStats.map(m => m.homeShots || globalAvgHomeShots));
            const GF_V = weightedAvg(teamVAwayStats.map(m => m.awayShots || globalAvgAwayShots));

            const lambdaL = (GF_L / globalAvgHomeShots) * globalAvgAwayShots;
            const lambdaV = (GF_V / globalAvgAwayShots) * globalAvgHomeShots;

            console.log(`    Lambdas: L=${lambdaL.toFixed(2)} (GF_L=${GF_L.toFixed(1)}), V=${lambdaV.toFixed(2)} (GF_V=${GF_V.toFixed(1)})`);

            const sim = runPoissonSimulation(lambdaL, lambdaV, CORRELATION_FACTOR);
            console.log(`    Probs: BTTS=${(sim.probBTTS*100).toFixed(1)}%, Over25=${(sim.probOU25*100).toFixed(1)}%`);

            // Mercados
            const marketsToEval = [];
            if (fixture.outcome === 'BTTS' || fixture.outcome === 'UNKNOWN') { // Siempre BTTS para tu JSON
                marketsToEval.push({ name: 'BTTS S√≠', prob: sim.probBTTS, isWin: fixture.homeGoals > 0 && fixture.awayGoals > 0, odd: fixture.odd, source: 'real' });
            }
            if (includeOver) {
                marketsToEval.push({ name: 'Over 2.5', prob: sim.probOU25, isWin: (fixture.homeGoals + fixture.awayGoals) > 2, odd: fixture.outcome === 'OVER' ? fixture.odd : (1 / sim.probOU25 + 0.05), source: fixture.outcome === 'OVER' ? 'real' : 'simulada' });
            }

            marketsToEval.forEach(market => {
                if (market.prob < PROB_MIN || market.prob > PROB_MAX) {
                    console.log(`    ${market.name} SKIP: Prob ${(market.prob*100).toFixed(1)}% fuera de ${PROB_MIN*100}-${PROB_MAX*100}%`);
                    return;
                }

                const bookieOdd = market.odd;
                const ev = (bookieOdd * market.prob) - 1;
                totalEV += ev;
                bets++;

                if (market.isWin) {
                    units += (bookieOdd - 1);
                    wins++;
                } else {
                    units -= 1;
                }

                console.log(`    ${market.name} BET: Prob ${(market.prob*100).toFixed(1)}%, Odd ${bookieOdd.toFixed(2)} (${market.source}), EV ${(ev*100).toFixed(1)}%, Win: ${market.isWin ? 'S√≠' : 'No'}`);

                details.push({
                    match: `${fixture.localTeam} vs ${fixture.visitantTeam}`,
                    market: market.name,
                    prob: (market.prob * 100).toFixed(2) + '%',
                    bookieOdd: bookieOdd.toFixed(2) + ` (${market.source})`,
                    ev: (ev * 100).toFixed(2) + '%',
                    outcome: market.isWin ? '‚úÖ S√≠' : '‚ùå No'
                });
            });
        });

        const yieldPct = bets > 0 ? (units / bets) * 100 : 0;
        const evAvg = bets > 0 ? totalEV / bets * 100 : 0;

        return { bets, units, yield: yieldPct, wins, evAvg, details };
    }

    function weightedAvg(values) {
        let sum = 0, weightSum = 0;
        for (let i = 0; i < values.length; i++) {
            const weight = Math.pow(DECAY_FACTOR, i);
            sum += values[i] * weight;
            weightSum += weight;
        }
        return weightSum > 0 ? sum / weightSum : values[0] || 3; // Fallback
    }

    // updateUI y toggleDetails (mismo que antes, omitido por espacio)
    function updateUI(weekly, totalUnits, totalBets, totalWins, avgEV) {
        document.getElementById('total-weeks').textContent = weekly.length;
        const netEl = document.getElementById('net-units');
        netEl.textContent = totalUnits.toFixed(2);
        netEl.className = totalUnits > 0 ? 'positive' : totalUnits < 0 ? 'negative' : '';
        document.getElementById('avg-yield').innerHTML = `<span class="${totalUnits > 0 ? 'positive' : totalUnits < 0 ? 'negative' : ''}">${(totalBets > 0 ? (totalUnits / totalBets * 100) : 0).toFixed(2)}%</span>`;
        document.getElementById('win-rate').textContent = (totalBets > 0 ? (totalWins / totalBets * 100) : 0).toFixed(2) + '%';

        const tbody = document.querySelector('#weekly-table tbody');
        tbody.innerHTML = '';
        weekly.forEach((w, i) => {
            const row = tbody.insertRow();
            const unitsClass = w.units > 0 ? 'positive' : w.units < 0 ? 'negative' : '';
            row.innerHTML = `
                <td>${w.weekStart}</td>
                <td>${w.bets}</td>
                <td class="${unitsClass}">${w.units.toFixed(2)}</td>
                <td class="${w.yield > 0 ? 'positive' : w.yield < 0 ? 'negative' : ''}">${w.yield.toFixed(2)}%</td>
                <td>${w.evAvg.toFixed(2)}%</td>
                <td><button onclick="toggleDetails(${i})">Ver</button></td>
            `;
        });

        window.weeklyDetails = weekly.reduce((acc, w, i) => { acc[i] = w.details; return acc; }, {});
    }

    function toggleDetails(index) {
        const detailsDiv = document.getElementById('details-section');
        const details = window.weeklyDetails[index];
        if (!details) return;

        const marketClass = (d) => d.market === 'BTTS S√≠' ? 'market-btts' : 'market-over';

        detailsDiv.innerHTML = `
            <h3>Detalles Semana ${index + 1}</h3>
            <table>
                <thead><tr><th>Partido</th><th>Mercado</th><th>Prob</th><th>Odd</th><th>EV (%)</th><th>Resultado</th></tr></thead>
                <tbody>${details.map(d => `<tr class="${marketClass(d)}"><td>${d.match}</td><td>${d.market}</td><td>${d.prob}</td><td>${d.bookieOdd}</td><td>${d.ev}</td><td>${d.outcome}</td></tr>`).join('')}</tbody>
            </table>
        `;
        detailsDiv.classList.toggle('show');
    }

    // Inicial
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('status').id = 'status';
    });
</script>
</body>
</html>