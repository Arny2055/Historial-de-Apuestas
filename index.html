<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtester Semanal: BTTS S√≠ & Over 2.5 (Prioridad GG)</title>
    <style>
        body { font-family: 'Roboto', sans-serif; margin: 20px; background: #f9f9f9; color: #333; line-height: 1.6; }
        #container { max-width: 1200px; margin: auto; padding: 20px; background: white; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-radius: 8px; }
        h1, h2 { color: #123456; }
        button { padding: 10px 20px; background: #3d8bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #2a6bcc; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input[type="checkbox"] { margin-right: 10px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 8px; border: 1px solid #ddd; text-align: center; }
        th { background: #123456; color: white; }
        tr:nth-child(even) { background: #f5f5f5; }
        .positive { color: #2a9d8f; font-weight: bold; }
        .negative { color: #e63946; font-weight: bold; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; }
        .stat-box { padding: 15px; background: #f0f8ff; border-radius: 6px; text-align: center; }
        .stat-box p { font-size: 1.4em; font-weight: bold; margin: 5px 0 0; }
        .stat-box span { font-size: 0.9em; color: #56789a; }
        #status { margin: 10px 0; padding: 10px; border-radius: 4px; background: #e8f5e8; color: #2a9d8f; }
        #error { background: #ffebee; color: #c62828; }
        .details { display: none; margin-top: 10px; }
        .details.show { display: block; }
        .market-btts { background: #e3f2fd; }
        .market-over { background: #f3e5f5; }
    </style>
</head>
<body>
<div id="container">
    <h1>Backtester Semanal: Prioridad BTTS S√≠ (usa Odd real de GG)</h1>
    <p>Carga tu JSON (para GG). Simula BTTS con cuota real; Over 2.5 opcional (simulada). Filtros relajados para m√°s bets.</p>
    
    <input type="file" id="json-input" accept=".json" onchange="loadJSON()">
    <label><input type="checkbox" id="include-over" checked> Incluir Over 2.5 (simulado)</label>
    <button id="run-btn" onclick="runSimulation()" disabled>üî¨ Simular Backtests Semanales</button>
    <div id="status">Estatus: Esperando JSON...</div>
    
    <section id="results-section" style="display: none;">
        <h2>üìä Resultados Agregados</h2>
        <div class="stats-grid">
            <div class="stat-box"><span>Semanas Simuladas</span><p id="total-weeks">0</p></div>
            <div class="stat-box"><span>Unidades Netas Totales</span><p id="net-units" class="positive">0.00</p></div>
            <div class="stat-box"><span>Yield Promedio (%)</span><p id="avg-yield" class="positive">0.00%</p></div>
            <div class="stat-box"><span>Tasa de Acierto (%)</span><p id="win-rate">0.00%</p></div>
        </div>
        
        <h2>Detalles por Semana</h2>
        <table id="weekly-table">
            <thead>
                <tr>
                    <th>Semana (Domingo Inicio)</th>
                    <th>Mercados Analizados</th>
                    <th>Unidades Netas</th>
                    <th>Yield (%)</th>
                    <th>EV Promedio (%)</th>
                    <th>Acciones</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        
        <div id="details-section"></div>
    </section>
</div>

<script>
    let allData = []; // Array de partidos parseados
    const SIX_MONTHS_MS = 6 * 30 * 24 * 60 * 60 * 1000;
    const ONE_WEEK_MS = 7 * 24 * 60 * 60 * 1000;
    const MIN_MATCHES = 10; // Relajado
    const EDGE_MARGIN = 0.10;
    const PROB_MIN = 0.60; const PROB_MAX = 0.75;
    const CORRELATION_FACTOR = 0.04;
    const DECAY_FACTOR = 0.95;
    const MATCHES_LIMIT = 5; // Relajado

    // Poisson (mismo que antes)
    const factorialCache = { 0: 1, 1: 1 };
    function factorial(n) {
        if (n in factorialCache) return factorialCache[n];
        let result = 1;
        for (let i = 2; i <= n; i++) result *= i;
        return factorialCache[n] = result;
    }

    function poisson(k, lambda) {
        if (k < 0) return 0;
        if (lambda <= 0) return k === 0 ? 1 : 0;
        return (Math.exp(-lambda) * Math.pow(lambda, k)) / factorial(k);
    }

    function runPoissonSimulation(lambdaL, lambdaV, correlationFactor) {
        const maxGoals = 4;
        let probMatrix = [];
        let totalProb = 0;
        const P_plus = (lambda) => 1 - Array.from({ length: maxGoals }, (_, k) => poisson(k, lambda)).reduce((a, b) => a + b, 0);

        for (let i = 0; i <= maxGoals; i++) {
            probMatrix[i] = [];
            for (let j = 0; j <= maxGoals; j++) {
                const probL = (i < maxGoals) ? poisson(i, lambdaL) : P_plus(lambdaL);
                const probV = (j < maxGoals) ? poisson(j, lambdaV) : P_plus(lambdaV);
                probMatrix[i][j] = probL * probV;
                totalProb += probMatrix[i][j];
            }
        }

        const normFactor = 1.0 / totalProb;
        let normalizedProbMatrix = probMatrix.map(row => row.map(p => p * normFactor));
        let finalProbMatrix = JSON.parse(JSON.stringify(normalizedProbMatrix));

        if (correlationFactor > 0) {
            const prob00 = normalizedProbMatrix[0][0];
            const prob11 = normalizedProbMatrix[1][1];
            const sumDraws = prob00 + prob11;
            if (sumDraws > 0) {
                finalProbMatrix[0][0] += correlationFactor * (prob00 / sumDraws);
                finalProbMatrix[1][1] += correlationFactor * (prob11 / sumDraws);
                const sumDrawsNew = finalProbMatrix[0][0] + finalProbMatrix[1][1];
                const sumNonDrawsOrig = 1.0 - sumDraws;
                const sumNonDrawsReq = 1.0 - sumDrawsNew;
                const reduction = sumNonDrawsOrig > 0 ? sumNonDrawsReq / sumNonDrawsOrig : 1.0;
                for (let i = 0; i <= maxGoals; i++) {
                    for (let j = 0; j <= maxGoals; j++) {
                        if (!((i === 0 && j === 0) || (i === 1 && j === 1))) {
                            finalProbMatrix[i][j] = normalizedProbMatrix[i][j] * reduction;
                        }
                    }
                }
            }
        }

        let probBTTS = 0, probOU25 = 0;
        for (let i = 0; i <= maxGoals; i++) {
            for (let j = 0; j <= maxGoals; j++) {
                const P = finalProbMatrix[i][j];
                if (i >= 1 && j >= 1) probBTTS += P;
                if (i + j > 2) probOU25 += P;
            }
        }

        return { probBTTS, probOU25 };
    }

    function loadJSON() {
        const file = document.getElementById('json-input').files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                let rawData = JSON.parse(e.target.result);
                if (!Array.isArray(rawData)) rawData = [rawData];

                allData = rawData.map(match => {
                    const [localTeam, visitantTeam] = match.Match.split(' - ');
                    const [homeGoalsStr, awayGoalsStr] = match['Result FT'] ? match['Result FT'].split('-') : ['0', '0'];
                    const homeGoals = parseInt(homeGoalsStr) || 0;
                    const awayGoals = parseInt(awayGoalsStr) || 0;
                    const dateStr = match.Date.replace(/^(lun\.|mar\.|mi√©\.|jue\.|vie\.|s√°b\.|dom\.\,?\s?)?/i, '');
                    const date = new Date(dateStr);

                    let outcome = 'UNKNOWN';
                    if (match['Desired Outcome'] === 'GG') outcome = 'BTTS';
                    else if (match['Desired Outcome'] === 'Over 2.5') outcome = 'OVER';

                    return {
                        date: isNaN(date.getTime()) ? new Date(0) : date,
                        league: match.League,
                        localTeam: localTeam.trim(),
                        visitantTeam: visitantTeam.trim(),
                        homeGoals,
                        awayGoals,
                        odd: parseFloat(match.Odd) || 2.0,
                        outcome,
                        result: match.Result === 'Winning' ? 'Ganada' : 'Perdida',
                        homeShots: parseInt(match['Home OnGoal Shots at FT']) || 3,
                        awayShots: parseInt(match['Away OnGoal Shots at FT']) || 3
                    };
                }).filter(m => !isNaN(m.date.getTime()))
                  .sort((a, b) => a.date - b.date);

                if (allData.length === 0) throw new Error('No hay datos v√°lidos con fechas parseables.');
                
                document.getElementById('status').innerHTML = `<span class="positive">‚úÖ Cargados ${allData.length} partidos (BTTS: ${allData.filter(m => m.outcome === 'BTTS').length}, Over: ${allData.filter(m => m.outcome === 'OVER').length}).</span>`;
                document.getElementById('run-btn').disabled = false;
            } catch (err) {
                document.getElementById('status').id = 'error';
                document.getElementById('status').innerHTML = `<span class="negative">‚ùå Error: ${err.message}.</span>`;
            }
        };
        reader.readAsText(file);
    }

    function runSimulation() {
        if (allData.length === 0) return;
        document.getElementById('results-section').style.display = 'block';
        document.getElementById('status').innerHTML = '<span class="positive">Simulando (prioridad BTTS con odd real)...</span>';

        const includeOver = document.getElementById('include-over').checked;
        const startDate = allData[0].date;
        const endDate = allData[allData.length - 1].date;
        let currentSunday = new Date(startDate.getTime() + SIX_MONTHS_MS);
        currentSunday.setDate(currentSunday.getDate() + ((7 - currentSunday.getDay()) % 7));

        const weeklyResults = [];
        let totalUnits = 0, totalBets = 0, totalWins = 0, totalEVSum = 0;

        while (currentSunday < endDate) {
            const windowStart = new Date(currentSunday.getTime() - SIX_MONTHS_MS);
            const nextWeekStart = new Date(currentSunday.getTime() + 24 * 60 * 60 * 1000);
            const nextWeekEnd = new Date(currentSunday.getTime() + ONE_WEEK_MS);

            const statsData = allData.filter(m => m.date >= windowStart && m.date < currentSunday);
            const fixtures = allData.filter(m => m.date >= nextWeekStart && m.date < nextWeekEnd);

            if (statsData.length < MIN_MATCHES || fixtures.length === 0) {
                console.log(`Semana ${currentSunday.toLocaleDateString()}: Saltada (stats: ${statsData.length}, fixtures: ${fixtures.length})`);
                currentSunday = new Date(currentSunday.getTime() + ONE_WEEK_MS);
                continue;
            }

            const weekResults = simulateWeekBacktest(statsData, fixtures, includeOver);
            weeklyResults.push({
                weekStart: currentSunday.toLocaleDateString('es-ES'),
                bets: weekResults.bets,
                units: weekResults.units,
                yield: weekResults.yield,
                evAvg: weekResults.evAvg,
                details: weekResults.details
            });

            totalUnits += weekResults.units;
            totalBets += weekResults.bets;
            totalWins += weekResults.wins;
            totalEVSum += weekResults.evAvg * weekResults.bets;

            currentSunday = new Date(currentSunday.getTime() + ONE_WEEK_MS);
        }

        updateUI(weeklyResults, totalUnits, totalBets, totalWins, totalEVSum / (totalBets || 1));
        document.getElementById('status').innerHTML = `<span class="positive">‚úÖ Completa: ${weeklyResults.length} semanas (${totalBets} mercados totales).</span>`;
    }

    function simulateWeekBacktest(stats, fixtures, includeOver) {
        let bets = 0, units = 0, wins = 0, totalEV = 0;
        const details = [];

        const globalAvgHomeShots = stats.reduce((sum, m) => sum + m.homeShots, 0) / stats.length || 3;
        const globalAvgAwayShots = stats.reduce((sum, m) => sum + m.awayShots, 0) / stats.length || 3;

        fixtures.forEach((fixture, fixIndex) => {
            const teamLHomeStats = stats.filter(m => m.localTeam === fixture.localTeam && m.league === fixture.league).slice(-MATCHES_LIMIT);
            const teamVAwayStats = stats.filter(m => m.visitantTeam === fixture.visitantTeam && m.league === fixture.league).slice(-MATCHES_LIMIT);

            if (teamLHomeStats.length < MATCHES_LIMIT || teamVAwayStats.length < MATCHES_LIMIT) {
                console.log(`Fixture ${fixIndex} (${fixture.localTeam} vs ${fixture.visitantTeam}): Pocos matches (${teamLHomeStats.length}/${teamVAwayStats.length})`);
                return;
            }

            const GF_L = weightedAvg(teamLHomeStats.map(m => m.homeShots));
            const GF_V = weightedAvg(teamVAwayStats.map(m => m.awayShots));

            const lambdaL = (GF_L / globalAvgHomeShots) * globalAvgAwayShots;
            const lambdaV = (GF_V / globalAvgAwayShots) * globalAvgHomeShots;

            if (lambdaL <= 0 || lambdaV <= 0) {
                console.log(`Fixture ${fixIndex}: Lambdas inv√°lidas (${lambdaL.toFixed(2)}/${lambdaV.toFixed(2)})`);
                return;
            }

            const sim = runPoissonSimulation(lambdaL, lambdaV, CORRELATION_FACTOR);

            // Evaluar mercados seg√∫n outcome y toggle
            const marketsToEval = [];
            if (fixture.outcome === 'BTTS') {
                marketsToEval.push({ name: 'BTTS S√≠', prob: sim.probBTTS, isWin: fixture.homeGoals > 0 && fixture.awayGoals > 0, odd: fixture.odd, source: 'real' });
            }
            if (includeOver && fixture.outcome === 'OVER') {
                marketsToEval.push({ name: 'Over 2.5', prob: sim.probOU25, isWin: (fixture.homeGoals + fixture.awayGoals) > 2, odd: fixture.odd, source: 'real' });
            }
            if (includeOver && fixture.outcome !== 'BTTS') { // Simular Over si toggle y no es GG
                marketsToEval.push({ name: 'Over 2.5', prob: sim.probOU25, isWin: (fixture.homeGoals + fixture.awayGoals) > 2, odd: 1 / sim.probOU25 + 0.1, source: 'simulada' });
            }

            marketsToEval.forEach(market => {
                if (market.prob < PROB_MIN || market.prob > PROB_MAX) {
                    console.log(`Fixture ${fixIndex} - ${market.name}: Prob ${ (market.prob*100).toFixed(2) }% fuera de rango`);
                    return;
                }

                const impliedOdd = 1 / market.prob;
                const minOdd = impliedOdd + EDGE_MARGIN;
                const bookieOdd = market.odd; // Real o simulada seg√∫n source

                const ev = (bookieOdd * market.prob) - 1;
                totalEV += ev;
                bets++;

                if (market.isWin) {
                    units += (bookieOdd - 1);
                    wins++;
                } else {
                    units -= 1;
                }

                console.log(`Fixture ${fixIndex} - ${market.name}: Bet! Prob ${(market.prob*100).toFixed(2)}%, Odd ${bookieOdd.toFixed(2)} (source: ${market.source}), EV ${(ev*100).toFixed(2)}%, Win: ${market.isWin}`);

                details.push({
                    match: `${fixture.localTeam} vs ${fixture.visitantTeam}`,
                    market: market.name,
                    prob: (market.prob * 100).toFixed(2) + '%',
                    bookieOdd: bookieOdd.toFixed(2) + (market.source === 'real' ? ' (real)' : ' (sim)'),
                    ev: (ev * 100).toFixed(2) + '%',
                    outcome: market.isWin ? '‚úÖ S√≠' : '‚ùå No'
                });
            });
        });

        const yieldPct = bets > 0 ? (units / bets) * 100 : 0;
        const evAvg = bets > 0 ? totalEV / bets * 100 : 0;

        return { bets, units, yield: yieldPct, wins, evAvg, details };
    }

    function weightedAvg(values) {
        let sum = 0, weightSum = 0;
        for (let i = 0; i < values.length; i++) {
            const weight = Math.pow(DECAY_FACTOR, i);
            sum += values[i] * weight;
            weightSum += weight;
        }
        return weightSum > 0 ? sum / weightSum : 0;
    }

    function updateUI(weekly, totalUnits, totalBets, totalWins, avgEV) {
        document.getElementById('total-weeks').textContent = weekly.length;
        const netEl = document.getElementById('net-units');
        netEl.textContent = totalUnits.toFixed(2);
        netEl.className = totalUnits > 0 ? 'positive' : totalUnits < 0 ? 'negative' : '';
        document.getElementById('avg-yield').innerHTML = `<span class="${totalUnits > 0 ? 'positive' : totalUnits < 0 ? 'negative' : ''}">${(totalBets > 0 ? (totalUnits / totalBets * 100) : 0).toFixed(2)}%</span>`;
        document.getElementById('win-rate').textContent = (totalBets > 0 ? (totalWins / totalBets * 100) : 0).toFixed(2) + '%';

        const tbody = document.querySelector('#weekly-table tbody');
        tbody.innerHTML = '';
        weekly.forEach((w, i) => {
            const row = tbody.insertRow();
            const unitsClass = w.units > 0 ? 'positive' : w.units < 0 ? 'negative' : '';
            row.innerHTML = `
                <td>${w.weekStart}</td>
                <td>${w.bets}</td>
                <td class="${unitsClass}">${w.units.toFixed(2)}</td>
                <td class="${w.yield > 0 ? 'positive' : w.yield < 0 ? 'negative' : ''}">${w.yield.toFixed(2)}%</td>
                <td>${w.evAvg.toFixed(2)}%</td>
                <td><button onclick="toggleDetails(${i})">Ver Detalles</button></td>
            `;
        });

        window.weeklyDetails = weekly.reduce((acc, w, i) => { acc[i] = w.details; return acc; }, {});
    }

    function toggleDetails(index) {
        const detailsDiv = document.getElementById('details-section');
        const details = window.weeklyDetails[index];
        if (!details) return;

        const marketClass = (d) => d.market === 'BTTS S√≠' ? 'market-btts' : 'market-over';

        detailsDiv.innerHTML = `
            <h3>Detalles Semana ${index + 1} (${window.weeklyDetails[index].weekStart})</h3>
            <table>
                <thead><tr><th>Partido</th><th>Mercado</th><th>Prob Modelo</th><th>Cuota Bookie</th><th>EV (%)</th><th>Resultado Real</th></tr></thead>
                <tbody>${details.map(d => `<tr class="${marketClass(d)}"><td>${d.match}</td><td>${d.market}</td><td>${d.prob}</td><td>${d.bookieOdd}</td><td>${d.ev}</td><td>${d.outcome}</td></tr>`).join('')}</tbody>
            </table>
            <p><em>Colores: Azul=BTTS (odd real), Lila=Over (simulada). Ver console para logs.</em></p>
        `;
        detailsDiv.classList.toggle('show');
    }

    // Inicial
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('status').id = 'status';
    });
</script>
</body>
</html>